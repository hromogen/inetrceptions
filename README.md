#Перетин многокутників

## Основна інформація
Папка містить файли, що `ingex.html`, `solution.js`, `ingex.css` та `ingex.js`. У файлі `ingex.js` розміщено приклад – ввідний об’єкт ́́́́`examples`, що містить 2 властивості, які є масивами вершин многокутників (заданих об’єктами виду { x: Координата1,  y: Координата2 }, де координати є цілими числами). Також у файлі міститься функція `drawPath`, яка на основі набору даних про вершини многокутників, даних про стиль, заданих у файлі *index.css* та даних про колір реалізує їх рисунок на сторінці. Дані про вершини многокутників, що є перетинами заданих многокутників розраховує функція `intersect`, розміщена у файлі `solution.js`
### Файл `solution.js`
На вході функція `intersect()` приймає два масиви об’єктів, що задають вершини многокутників: `fig1` та `fig2`
Спочатку в глобальній області видимості функції задається низка функцій, що використовується нижче 
 
 * `step` Приймає номер елемента в масиві даних і сам масив а повертає номер елемента, скорегований таким чином, щоб він не був від’ємним та не більшим за довжину масиву.
 * `rotate` Приймає об’єкти у вигляді координатів 3-х точок, повертає від’ємне значення якщо точка С повернута відносно відрізку АВ за годинниковою стрілкою інакше – додатнє 
 * `isCrossed` Приймає об’єкти у вигляді координатів 4-х точок, на основі обрахованих за допомогою функції `rotate` положень цих точок одна відносно іншої обраховує, чи перетинаються відрізки АВ і CD  
 * `findCrP(A,B,C,D)` шукає точки перетину 4-х ввідних точок заданих у вигляді об’єктів. Для цього вона за допомогою функції `findEq(E,F)` шукає основні множники в стандартному рівнянні прямих ( виду a*x + b*y + c = 0) для заданих точок попарно після чого у рівнянні з шкільного підручника геометрії, що слідує після `return` обраховує координати точок перетину, які й повертає у тій самій формі об’єкту, що й задані точки.
 * `isInPol` приймає на вході масив вершин многокутника й точку, а повертає значення у вигляді `true` якщо точка лежить всередині многокутника й `false` – якщо ні. Для реалізації цієї фунції за допомогою функції `isCrossed` перевіряється кількість перетинів між сторонами многокутника та відрізком між шуканою точкою та точкою з координатами {500; (координата заданої точки + корінь з 2)} (така реалізація можлива лише якщо вершини многокутників задані цілими точками). У випадку парної кількості перетинів точка лежить за межами многокуника, у випадку непарної – всередині. 
 * `findS(mass)` за заданим масивом шукає його площу. Для цього вона спочатку шукає точки перетину між сторонами заданого масиву (якщо він не є опуклим) і включає їх у масив вершин двічі (для коректного обходу). Потім за формулою пошуку площі за координатами вершин многокутника повертає величину площі. 

Пошук вершин многокутників, що є перетинами заданих, складається з трьох етапів. Перед першим етапом нам слід перевірити, чи задані вершини ввідних многокутників в одному напрямку обходу. Для цього використовуємо функцію `rotate` та фрагмент коду      
```javascript     
      if (rotate(fig1[0], fig1[1], fig1[2]) < 0)
        {fig1.reverse();}
      if (rotate(fig2[0], fig2[1], fig2[2]) < 0)
         {fig2.reverse();}
``` 
Якщо порядок першин яккогось із многокутників задано за годинниковою стрілкою – змінюємо положення вершин. 
######Перший етап
На першому етапі нам слід визначити точки перетину між сторонами заданих многокутників. Для цього використовується функція 
`AddCrossp`. На вході вона приймає два масиви вершин многокутників, повертає масив вершин **першого** з вхідних многокутників, де між кожною з двох сусідніх вершин вставлено точки перетину з другим многокутником. 
Для цього використовується допоміжна функціця `dist`, яка шукає відстань між точками за їх координатами. 
Процес реалізується за рахунок подвійного перебору `for`, де у зовнішньому циклі задано многокутник, до якого будуть включені отримані вершини, до внутрішнього – інший многокутник. Оскільки функція `isCrossed` некоректно працює із граничними значеннями, всередині циклів задано перевірку на те, чи є n-а вершина другого многокутника точкою перетину. Якщо так, проводиться перевірка на дотичність за допомогою функції `isCrossed`. Якщо точка є дотичною, її властивість `EntOrEx` (яку буде використано далі) набирає значення [0, 0], якщо ні – точка включається в масив вершин. Також на цьому етапі всі перевірені вершини отримують властивість `visit: false`, яка буде використана далі для визначення закінчення обходу. Точки перетину отримують також властивість `alph`рівне відношенню (відстані між точкою та вершиною многокутника з меншим індексом)/(довжина сторони многокутника). По заверщенню кожного з внутрішніх циклів його результат записуєтьсчя в результуючий масив методом `concat` із попереднім сортуванням за заначенням alph
```javascript 
 finFig = finFig.concat(crossed.sort(function(a,b) {if (a.alph > b.alph) return 1; if (a.alph <= b.alph) return -1}));
```
По завершенню зовнішнього циклу функція повертає finFig;

######Другий етап
Реалізовано у функції `marker`, яка на вході отримує два масиви вершин + точок перетину а повертає масив промаркованих масивів, певні точки перетину позначаються як "Входи" (об’єкт набуває властивості `EntOrEx:[1,0]`) або "Виходи"  (об’єкт набуває властивості `EntOrEx:[0,1]`). Цей процес реалізує внутрішня функція `MarkTheWay`, яка приймає точку, яку статус якої слід визначити (qpt), точку, з індексом на 1 менше (pt1), масив точок, що входять у інший многокутник (othm), масив точок, що входять у даний  многокутник (qm) та індекс точки у другому многокутнику (n). Дана функція реалізується лишен для визначених точок перетину, для чого знову відкривається подвійний цикл `for`
В першу чергу функція визначає, чи точка з індексом, меншим на 1, має статус "EntOrEx", який не є [0,0]. Якщо так, вона повертає значення протилежне попередній точці (якщо попередня точка була "Входом", ця напевно буде "Виходом"). Якщо ні, функція обраховує значення "Вхід"/"Вихід" даної точки за тим, чи є середини відрізків між нею та сусідніми точками іншого
многокутника в чи поза даним многокутником 
```javascript
    {  var g = {x: (qpt.x + othm[step(j-1, othm)].x)/2, y: (qpt.y + othm[step(j-1, othm)].y)/2}
               qpt.EntOrEx = [isInPol(qm, g), (isInPol(qm, g) + 1)%2];
    }
```
Функція повертає точку, промарковану для **даного многокутника** qpt;
        };
Також в процесі обходу для кожної точки перетину задається властивість `neig` в яке записується номер точки, ідентичної їй, у іншому многокутнику.

######Третій етап
Функція `findRes` приймає масив вершин/точок перетину, "по якому" буде відбуватись обхід (WalkMass) та інший масив  вершин/точок перетину, із яким буде відбуватись порівняння (RefMass). Обхід реалізовано у функції `walking(mass,d,t)`, де `mass` – масив масивів, **із яких індекс 0 повинен мати WalkMass**, `d` – індекс елементу, отриманий із попередньої ітерації обходу, `t` – величина, яка визначає, елементи якого масиву запам’ятовуються (слугує своєрідним "перемикачем масивів" в процесі обходу)
У блоці 
```javascript        
        {
          if (mass[t][d].EntOrEx[1] == 0)
            { d = d++;
              for(;(("EntOrEx" in mass[t][d])?(mass[t][d].EntOrEx[0] == 0):(isInPol(mass[(t+1)%2], mass[t][d]))); 
                d++) 
              { mass[t][d].visit = true;
                 Res.push(mass[t][d]);
                if ("neig" in mass[t][d]) {mass[(t+1)%2][mass[t][d].neig].visit = true;}
               }
              }
            else if (mass[t][d].EntOrEx[0] == 0)
            {d--
              for(;(("EntOrEx" in mass[t][d])?(mass[t][d].EntOrEx[1] == 0):(isInPol(mass[(t+1)%2], mass[t][d]))); 
                d--) 
              { mass[t][d].visit = true;
                Res.push(mass[t][d]);
                if ("neig" in mass[t][d]) {mass[(t+1)%2][mass[t][d].neig].visit = true;}
              }
            }
        return Res;
      }
    ```
    Визначається, чи є ввідна точка з індексом "d" масиву з індексом "t" "Входом", чи "Виходом". Якщо вона є "Входом", відбувається запам’ятовування елементів у масив результатів Res **зі зростанням індексу** до точки, що є "Виходом"". Якщо ввідна точка є "Виходом" відбувається той самий процес **зі спаданням індексу**, поки не буде знайдено точку "Входу". 
    **При обході точки із властивістю `EntOrEx: [0,0]` ігноруються. Також кожна з "відвіданих" точок отримує властивість `visit: true`**
    Функція повертає отриманий масив Res = [];
    Процеч обходу реалізується до досягнення кінця масиву `WalkMass` у циклі `for`. Відбувається перебір точок і перевіряється, чи вони вже відвідані, якщо так – ігноруються. Якщо точка не відвідана, перевіряється, чи вона є входом, чи виходом. Якщо так, реалізується наступний блок операцій:
    ```javascript
            { 
              stPoint = {x: WalkMass[q].x, y: WalkMass[q].y};
              WalkMass[q].visit = true;
              RefMass[WalkMass[q].neig].visit = true
              resulting = walking([WalkMass, RefMass], WalkMass[q].neig, 1);
              u = resulting[resulting.length - 1].neig;
          }
    ```
    Спочатку задається точка початку `stPoint` із координатами точки масиву, де було визначено аявність "Входу"/"Виходу."
    Потім точка масиву а також її "сусід" позначаються "відвіданою". Виконується перша "прогулянка" від точки перетину до наступної точки перетину, **по масиву `RefMass`** в результаті чого отримуємо стартовий набір точок майбутнього многокутника. 
    Далі у циклі  
    ```javascript
    for (var i = 2, TempRes = []; 
                ((stPoint.x != resulting[resulting.length-1].x) ||
                 (stPoint.y != resulting[resulting.length-1].y)); 
                i++)
                { resulting = resulting.concat(walking([WalkMass, RefMass],u,(i%2)));
                  u = resulting[resulting.length - 1].neig;
                }
             
     ```  
     реалізується почерговий обхід вершин многокутників. Точка виходу – досягнення циклом стартової точки stPoint. В даному випадку маркером того, по якому з многокутників відбувається "прогулянка" є ітератор i, який щоразу збільшується на 1. 
     Далі у функції `findS` перевіряється, чи площа отриманого многокутника більша 0.001, якщо так, результат додається до результуючого масиву.
     Також блок 
     ```javascript  
      else if (!("EntOrEx" in WalkMass[q]))
            {WalkMass[q].visit = true;}
    ```
    Реалізується, якщо при першому обході трапилась функція, яка не має маркеру "Входу"/"Виходу": вона позначається "відвіданою", після чого обхід продовжується
    Функція повертає масив із трьох значень: [Res, RefMass, WalkMass]. Res із них – отриманий масив із многокутників, RefMass, WalkMass – змінені вхідні масиви з відмітками точок про "відвідування"
#####Власне, виконання функції
  ```javascript
  var R = findRes(marker(AddCrossp(fig1, fig2), AddCrossp(fig2, fig1))[0],marker(AddCrossp(fig1, fig2), AddCrossp(fig2, fig1))[1]);
  ```
  Отримуємо масив результатів при обході вхідного масиву *fig1*, 
  ```javascript    
       var R1 = findRes(R[2], R[1]);
  ```
  Раптом чого не обійшли – перевіряємо при по результуючому масиву, отриманого із *fig2*  
  ```javascript    
  var RESULT = R[0].concat(R1[0]); 
    return RESULT;
  ```
  Методом `concat` додаємо результати цих двох процедур і повертаємо результат. 
